cg_tnet <- as.tnet(cg_tie_df, type = "weighted one-mode tnet")
cg.ig <- tnet_igraph(cg_tnet, type = "weighted one-mode tnet", directed = NULL)
cg.ig<- add_vertices(cg.ig, nv = length(valid_vertices), name = valid_vertices)
namesss <-data.frame(id = 1:35, node = colnames(concepts))
cg.stat <- as.network.matrix(cg_tnet)
View(namesss)
cg_tie_df$from <- as.integer(as.factor(cg_tie_df$from))
cg_tie_df$to <- as.integer(as.factor(cg_tie_df$to))
# Create the network object
cg_tnet <- as.tnet(cg_tie_df, type = "weighted one-mode tnet")
cg.ig <- tnet_igraph(cg_tnet, type = "weighted one-mode tnet", directed = NULL)
cg.ig<- add_vertices(cg.ig, nv = length(valid_vertices), name = valid_vertices)
namesss <-data.frame(id = 1:35, node = colnames(concepts))
cg.stat <- as.network.matrix(cg_tnet)
network.vertex.names(cg.stat) <- namesss$node
#get betweennes, power centrailitty, degree strength (based on weights), closeness, and constraints
cg.nodes<-data.frame(name=cg.stat%v%"vertex.names",
degree.wt=igraph::strength(cg.ig),
power.cent =igraph::power_centrality(cg.ig),
betweenness=sna::betweenness(cg.stat, gmode="graph"),
close=sna::closeness(cg.stat, gmode="graph"),
constraint=igraph::constraint(cg.ig))
eigen_cent_df <- as.data.frame(eigen_centrality(cg.ig))
eigen_cent_df <- head(eigen_cent_df,35)
cg.nodes<-cbind(cg.nodes, eigen_cent_df)
cg.nodes <- head(cg.nodes,35) # don't care about place holder empty columns,
cg.nodes <- cg.nodes[, 1:8]
head(cg.nodes, 6)
#STRUCTUAL Equivalence
#Average Cluster Method
cg.ase <- equiv.clust(cg.stat,
equiv.fun = "sedist",
cluster.method = "average",
method = "hamming",
mode = "graph")
plot(cg.ase, cg.ase$glabels)
#Partitioning Average Cluster Method -5
plot(cg.ase,labels = cg.ase$glabels)
rect.hclust(cg.ase$cluster, h = 5)
#testing block model
block_ase <-blockmodel(cg.stat, cg.wse, k=9, h=5) #tryin out 5
#View model
plot.block(block_wse, cex.lab=.5)
#testing block model
block_ase <-blockmodel(cg.stat, cg.wse, k=9, h=5) #tryin out 5
#View model
plot.block(block_ase, cex.lab=.5)
#Partitioning Average Cluster Method -5
plot(cg.ase,labels = cg.ase$glabels)
rect.hclust(cg.ase$cluster, h = 5)
View(cg.nodes)
#testing block model
block_ase <-blockmodel(cg.stat, cg.ase, k=9, h=5) #tryin out 5
#View model
plot.block(block_ase, cex.lab=.5)
blk_mod <- blockmodel(cg.stat, cg.ase, k=5)
# assign block membership to vertex attribute
c.stat%v%"role" <- blk_mod$block.membership[match(cg.stat%v%"vertex.names",
blk_mod$plabels)]
blk_mod <- blockmodel(cg.stat, cg.ase, k=5)
# assign block membership to vertex attribute
cg.stat%v%"role" <- blk_mod$block.membership[match(cg.stat%v%"vertex.names",
blk_mod$plabels)]
cg.nodes$role <- cg.stat%v%"role"
View(cg.nodes)
View(cg.nodes)
blk_mod <- blockmodel(cg.stat, cg.ase, k=5)
# assign block membership to vertex attribute
cg.stat%v%"role" <- blk_mod$block.membership[match(cg.stat%v%"vertex.names",
blk_mod$plabels)]
# attach
cg.nodes$role <- cg.stat%v%"role"
# summarize various network statistics by role
cg.nodes %>%
select(-name) %>%
group_by(role) %>%
mutate(n=n()) %>%
summarise_all(mean, na.rm = TRUE) %>%
as.matrix() %>%
print(digits=2)
library(blockmodeling)
# need a matric. object
cg.mat <- as.matrix(igraph::as_adj(cg.ig, attr = "nominations"))
# need a matric. object
cg.mat <- as.matrix(igraph::as_adj(cg.ig, attr = "weight"))
# inspect for accuracy
cg.mat[1:5, 1:5]
# need a matric. object
cg.mat <- as.matrix(as_adj(cg.ig, attr = "weight"))
# inspect for accuracy
cg.mat[1:5, 1:5]
View(cg.mat)
# need a matric. object
cg.mat <- as.matrix(as_adj(cg.ig, attr = "weight"))
# inspect for accuracy
cg.mat[1:5, 1:5]
cg.sedist <- blockmodeling::sedist(cg.mat)
cg.se <- sna::equiv.clust(cg.stat,
equiv.dist = cg.sedist)
View(cg.se)
# need a matric. object
cg.mat <- as.matrix(as_adj(cg.ig, attr = "weight"))
# inspect for accuracy
cg.mat[1:5, 1:5]
cg.sedist <- blockmodeling::sedist(cg.mat)
cg.se <- sna::equiv.clust(cg.stat,
equiv.dist = cg.sedist)
cg.se<-sna::equiv.clust(cg.stat,
equiv.dist=blockmodeling::sedist(cg.mat))
# need a matric. object
cg.mat <- as.matrix(as_adj(cg.ig, attr = "weight"))
cg.sedist <- blockmodeling::sedist(cg.mat)
cg.se <- sna::equiv.clust(cg.stat,
equiv.dist = cg.sedist)
cg.se<-sna::equiv.clust(cg.stat,
equiv.dist=blockmodeling::sedist(cg.mat))
cg.se
# need a matric. object
cg.mat <- as.matrix(as_adj(cg.ig, attr = "weight"))
cg.sedist <- blockmodeling::sedist(cg.mat)
cg.se <- sna::equiv.clust(cg.stat,
equiv.dist = cg.sedist)
cg.se<-sna::equiv.clust(cg.stat,
equiv.dist=blockmodeling::sedist(cg.mat))
plot.block(cg.se, cex.lab=.5)
# need a matric. object
cg.mat <- as.matrix(as_adj(cg.ig, attr = "weight"))
cg.sedist <- blockmodeling::sedist(cg.mat)
cg.se <- sna::equiv.clust(cg.stat,
equiv.dist = cg.sedist)
cg.se<-sna::equiv.clust(cg.stat,
equiv.dist=blockmodeling::sedist(cg.mat))
cg.se
plot(cg.se)
# need a matric. object
cg.mat <- as.matrix(as_adj(cg.stat, attr = "weight"))
# need a matric. object
cg.mat <- as.matrix(cg.ig, attr = "weight"))
# need a matric. object
cg.mat <- as.matrix(cg.ig, attr = "weight")
cg.sedist <- blockmodeling::sedist(cg.mat)
cg.se <- sna::equiv.clust(cg.stat,
equiv.dist = cg.sedist)
cg.se<-sna::equiv.clust(cg.stat,
equiv.dist=blockmodeling::sedist(cg.mat))
plot(cg.se)
# summarize various network statistics by role
cg.nodes %>%
select(-name) %>%
group_by(role) %>%
mutate(n=n()) %>%
summarise_all(mean, na.rm = TRUE) %>%
as.matrix() %>%
print(digits=2)
```
blk_mod <- blockmodel(cg.stat, cg.ase, k=5)
# assign block membership to vertex attribute
cg.stat%v%"role" <- blk_mod$block.membership[match(cg.stat%v%"vertex.names",
blk_mod$plabels)]
# attach
cg.nodes$role <- cg.stat%v%"role"
# summarize various network statistics by role
cg.nodes %>%
select(-name) %>%
group_by(role) %>%
mutate(n=n()) %>%
summarise_all(mean, na.rm = TRUE) %>%
as.matrix() %>%
print(digits=2)
# transform .ig into .mat object
monks.mat <- as.sociomatrix(cg.stat, attrname = "weight")
# inspect for accuracy
monks.mat[1:5, 1:5]
View(cg.stat)
# calcualte equivalence from specified distance matrix
monks.se<-sna::equiv.clust(monks.stat,
equiv.dist=blockmodeling::sedist(monks.mat))
# calcualte equivalence from specified distance matrix
monks.se<-sna::equiv.clust(cg.stat,
equiv.dist=blockmodeling::sedist(monks.mat))
# calcualte equivalence from specified distance matrix
monks.se<-sna::equiv.clust(cg.stat,
equiv.dist=blockmodeling::sedist(monks.mat))
plot(monks.se)
# need a matric. object
cg.mat <- as.sociomatrix(cg.stat, attr = "weight")
cg.sedist <- blockmodeling::sedist(cg.mat)
cg.se <- sna::equiv.clust(cg.stat,
equiv.dist = cg.sedist)
cg.se<-sna::equiv.clust(cg.stat,
equiv.dist=blockmodeling::sedist(cg.mat))
plot(cg.se)
# need a matric. object
cg.mat <- as.sociomatrix(cg.stat, attr = "weight")
cg.sedist <- blockmodeling::sedist(cg.mat)
cg.se <- sna::equiv.clust(cg.stat,
equiv.dist = cg.sedist)
cg.weight<-sna::equiv.clust(cg.stat,
equiv.dist=blockmodeling::sedist(cg.mat))
plot(cg.weight)
# need a matric. object
cg.mat <- as.sociomatrix(cg.stat, attr = "weight")
cg.sedist <- blockmodeling::sedist(cg.mat)
cg.se <- sna::equiv.clust(cg.stat,
equiv.dist = cg.sedist)
cg.se<-sna::equiv.clust(cg.stat,
equiv.dist=blockmodeling::sedist(cg.mat))
plot(cg.weightse)
# need a matric. object
cg.mat <- as.sociomatrix(cg.stat, attr = "weight")
cg.sedist <- blockmodeling::sedist(cg.mat)
cg.weights <- sna::equiv.clust(cg.stat,
equiv.dist = cg.sedist)
cg.weights<-sna::equiv.clust(cg.stat,
equiv.dist=blockmodeling::sedist(cg.mat))
plot(cg.weights)
concoR::concor_hca(list(cg.mat), p=9)
library(concoR)
concoR::concor_hca(list(cg.mat), p=9)
concoR::concor_hca(list(as.matrix.network(cg.stat)), p=9)
concoR::concor_hca(list(cg.stat), p=9)
concoR::concor_hca(list(as.matrix(cg.mat)), p=9)
results <- lapply(cg.mat, function(mat) {
concor_hca(mat, p = 9)
})
concoR::concor_hca(list(cg.mat), p=2)
concoR::concor_hca(list(cg.mat), p=1)
#testing block model
block_ase <-blockmodel(cg.stat, cg.ase, k=9, h=5) #tryin out 5
#View model
plot.block(block_ase, cex.lab=.5)
#Partitioning Average Cluster Method -5
plot(cg.ase,labels = cg.ase$glabels)
rect.hclust(cg.ase$cluster, h = 5)
# need a matric. object
cg.mat <- as.sociomatrix(cg.stat, attr = "weight")
cg.sedist <- blockmodeling::sedist(cg.mat)
cg.weights <- sna::equiv.clust(cg.stat,
equiv.dist = cg.sedist)
cg.weights<-sna::equiv.clust(cg.stat,
equiv.dist=blockmodeling::sedist(cg.mat))
plot(cg.weights,labels = cg.weights$glabels)
rect.hclust(cg.weights$cluster, h = 5)
# chosen blockmodel and chose partition partitions
cg_mod <- blockmodel(cg.stat, cg.weights, k=9)
# assign block membership to vertex attribute
cg.stat%v%"role" <- cg_mod$block.membership[match(cg.stat%v%"vertex.names",
cg_mod$plabels)]
GGally::ggnet2(cg.stat,
node.color = "role",
node.size = degree(cg.stat, gmode = "graph"),
node.label = "vertex.names",
node.alpha = .7)
# chosen blockmodel and chose partition partitions
cg_mod <- blockmodel(cg.stat, cg.weights, k=9)
# assign block membership to vertex attribute
cg.stat%v%"role" <- cg_mod$block.membership[match(cg.stat%v%"vertex.names",
cg_mod$plabels)]
GGally::ggnet2(cg.stat,
node.color = "role",
node.size = degree(cg.stat, gmode = "graph"),
node.label = "vertex.names",
node.alpha = .7)
# chosen blockmodel and chose partition partitions
cg_mod <- blockmodel(cg.stat, cg.ase, k=9)
# assign block membership to vertex attribute
cg.stat%v%"role" <- cg_mod$block.membership[match(cg.stat%v%"vertex.names",
cg_mod$plabels)]
GGally::ggnet2(cg.stat,
node.color = "role",
node.size = degree(cg.stat, gmode = "graph"),
node.label = "vertex.names",
node.alpha = .7)
blk_mod <- blockmodel(cg.stat, cg.ase, k=5)
# assign block membership to vertex attribute
cg.stat%v%"role" <- blk_mod$block.membership[match(cg.stat%v%"vertex.names",
blk_mod$plabels)]
# attach
cg.nodes$role <- cg.stat%v%"role"
# summarize various network statistics by role
cg.nodes %>%
select(-name) %>%
group_by(role) %>%
mutate(n=n()) %>%
summarise_all(mean, na.rm = TRUE) %>%
as.matrix() %>%
print(digits=2)
# chosen blockmodel and chose partition partitions
cg_mod <- blockmodel(cg.stat, cg.ase, k=9)
# assign block membership to vertex attribute
cg.stat%v%"role" <- cg_mod$block.membership[match(cg.stat%v%"vertex.names",
cg_mod$plabels)]
GGally::ggnet2(cg.stat,
node.color = "role",
node.size = degree(cg.stat, gmode = "graph"),
node.label = "vertex.names",
node.alpha = .7)
# chosen blockmodel and chose partition partitions
cg_mod <- blockmodel(cg.stat, cg.ase, k=5)
# assign block membership to vertex attribute
cg.stat%v%"role" <- cg_mod$block.membership[match(cg.stat%v%"vertex.names",
cg_mod$plabels)]
GGally::ggnet2(cg.stat,
node.color = "role",
node.size = degree(cg.stat, gmode = "graph"),
node.label = "vertex.names",
node.alpha = .7)
blk_mod <- blockmodel(cg.stat, cg.ase, k=9)
# assign block membership to vertex attribute
cg.stat%v%"role" <- blk_mod$block.membership[match(cg.stat%v%"vertex.names",
blk_mod$plabels)]
# attach
cg.nodes$role <- cg.stat%v%"role"
# summarize various network statistics by role
cg.nodes %>%
select(-name) %>%
group_by(role) %>%
mutate(n=n()) %>%
summarise_all(mean, na.rm = TRUE) %>%
as.matrix() %>%
print(digits=2)
# chosen blockmodel and chose partition partitions
cg_mod <- blockmodel(cg.stat, cg.ase, k=9)
# assign block membership to vertex attribute
cg.stat%v%"role" <- cg_mod$block.membership[match(cg.stat%v%"vertex.names",
cg_mod$plabels)]
GGally::ggnet2(cg.stat,
node.color = "role",
node.size = degree(cg.stat, gmode = "graph"),
node.label = "vertex.names",
node.alpha = .7)
blk_mod <- blockmodel(cg.stat, cg.ase, k=6)
# assign block membership to vertex attribute
cg.stat%v%"role" <- blk_mod$block.membership[match(cg.stat%v%"vertex.names",
blk_mod$plabels)]
# attach
cg.nodes$role <- cg.stat%v%"role"
# summarize various network statistics by role
cg.nodes %>%
select(-name) %>%
group_by(role) %>%
mutate(n=n()) %>%
summarise_all(mean, na.rm = TRUE) %>%
as.matrix() %>%
print(digits=2)
blk_mod <- blockmodel(cg.stat, cg.ase, k=4)
# assign block membership to vertex attribute
cg.stat%v%"role" <- blk_mod$block.membership[match(cg.stat%v%"vertex.names",
blk_mod$plabels)]
# attach
cg.nodes$role <- cg.stat%v%"role"
# summarize various network statistics by role
cg.nodes %>%
select(-name) %>%
group_by(role) %>%
mutate(n=n()) %>%
summarise_all(mean, na.rm = TRUE) %>%
as.matrix() %>%
print(digits=2)
blk_mod <- blockmodel(cg.stat, cg.ase, k=3)
# assign block membership to vertex attribute
cg.stat%v%"role" <- blk_mod$block.membership[match(cg.stat%v%"vertex.names",
blk_mod$plabels)]
# attach
cg.nodes$role <- cg.stat%v%"role"
# summarize various network statistics by role
cg.nodes %>%
select(-name) %>%
group_by(role) %>%
mutate(n=n()) %>%
summarise_all(mean, na.rm = TRUE) %>%
as.matrix() %>%
print(digits=2)
blk_mod <- blockmodel(cg.stat, cg.ase, k=2)
# assign block membership to vertex attribute
cg.stat%v%"role" <- blk_mod$block.membership[match(cg.stat%v%"vertex.names",
blk_mod$plabels)]
# attach
cg.nodes$role <- cg.stat%v%"role"
# summarize various network statistics by role
cg.nodes %>%
select(-name) %>%
group_by(role) %>%
mutate(n=n()) %>%
summarise_all(mean, na.rm = TRUE) %>%
as.matrix() %>%
print(digits=2)
# chosen blockmodel and chose partition partitions
cg_mod <- blockmodel(cg.stat, cg.ase, k=6)
# assign block membership to vertex attribute
cg.stat%v%"role" <- cg_mod$block.membership[match(cg.stat%v%"vertex.names",
cg_mod$plabels)]
GGally::ggnet2(cg.stat,
node.color = "role",
node.size = degree(cg.stat, gmode = "graph"),
node.label = "vertex.names",
node.alpha = .7)
# chosen blockmodel and chose partition partitions
cg_mod <- blockmodel(cg.stat, cg.ase, k=2)
# assign block membership to vertex attribute
cg.stat%v%"role" <- cg_mod$block.membership[match(cg.stat%v%"vertex.names",
cg_mod$plabels)]
GGally::ggnet2(cg.stat,
node.color = "role",
node.size = degree(cg.stat, gmode = "graph"),
node.label = "vertex.names",
node.alpha = .7)
# chosen blockmodel and chose partition partitions
cg_mod <- blockmodel(cg.stat, cg.ase, k3)
# chosen blockmodel and chose partition partitions
cg_mod <- blockmodel(cg.stat, cg.ase, k=3)
# assign block membership to vertex attribute
cg.stat%v%"role" <- cg_mod$block.membership[match(cg.stat%v%"vertex.names",
cg_mod$plabels)]
GGally::ggnet2(cg.stat,
node.color = "role",
node.size = degree(cg.stat, gmode = "graph"),
node.label = "vertex.names",
node.alpha = .7)
# chosen blockmodel and chose partition partitions
cg_mod <- blockmodel(cg.stat, cg.ase, k=7)
# assign block membership to vertex attribute
cg.stat%v%"role" <- cg_mod$block.membership[match(cg.stat%v%"vertex.names",
cg_mod$plabels)]
GGally::ggnet2(cg.stat,
node.color = "role",
node.size = degree(cg.stat, gmode = "graph"),
node.label = "vertex.names",
node.alpha = .7)
#testing block model
block_ase <-blockmodel(cg.stat, cg.ase, k=9, h=5) #tryin out 5
#View model
plot.block(block_ase, cex.lab=.5)
blk_mod <- blockmodel(cg.stat, cg.ase, k=9)
# assign block membership to vertex attribute
cg.stat%v%"role" <- blk_mod$block.membership[match(cg.stat%v%"vertex.names",
blk_mod$plabels)]
# attach
cg.nodes$role <- cg.stat%v%"role"
# summarize various network statistics by role
cg.nodes %>%
select(-name) %>%
group_by(role) %>%
mutate(n=n()) %>%
summarise_all(mean, na.rm = TRUE) %>%
as.matrix() %>%
print(digits=2)
# chosen blockmodel and chose partition partitions
cg_mod <- blockmodel(cg.stat, cg.ase, k=9)
# assign block membership to vertex attribute
cg.stat%v%"role" <- cg_mod$block.membership[match(cg.stat%v%"vertex.names",
cg_mod$plabels)]
GGally::ggnet2(cg.stat,
node.color = "role",
node.size = degree(cg.stat, gmode = "graph"),
node.label = "vertex.names",
node.alpha = .7)
#Partitioning Average Cluster Method -5
plot(cg.ase,labels = cg.ase$glabels)
rect.hclust(cg.ase$cluster, h = 5)
#testing block model
block_ase <-blockmodel(cg.stat, cg.ase, k=9, h=5) #tryin out 5
#View model
plot.block(block_ase, cex.lab=.5)
#STRUCTUAL Equivalence
#Average Cluster Method
cg.ase <- equiv.clust(cg.stat,
equiv.fun = "sedist",
cluster.method = "average",
method = "hamming",
mode = "graph")
cg.ase <- equiv.clust(cg.stat,
equiv.fun = "sedist",
cluster.method = "average",
method = "hamming",
mode = "graph")
cg_tie_df$from <- as.integer(as.factor(cg_tie_df$from))
cg_tie_df$to <- as.integer(as.factor(cg_tie_df$to))
# Create the network object
cg_tnet <- as.tnet(cg_tie_df, type = "weighted one-mode tnet")
cg.ig <- tnet_igraph(cg_tnet, type = "weighted one-mode tnet", directed = NULL)
cg.ig<- add_vertices(cg.ig, nv = length(valid_vertices), name = valid_vertices)
namesss <-data.frame(id = 1:35, node = colnames(concepts))
cg.stat <- as.network.matrix(cg_tnet)
network.vertex.names(cg.stat) <- namesss$node
#STRUCTUAL Equivalence
#Average Cluster Method
cg.ase <- equiv.clust(cg.stat,
equiv.fun = "sedist",
cluster.method = "average",
method = "hamming",
mode = "graph")
#STRUCTUAL Equivalence
#Average Cluster Method
cg.ase <- equiv.clust(cg.stat,
equiv.fun = "sedist",
cluster.method = "average",
method = "binary",
mode = "graph")
#STRUCTUAL Equivalence
#Average Cluster Method
cg.ase <- equiv.clust(cg.stat,
equiv.fun = "sedist",
cluster.method = "average",
sna::method = "hamming",
#STRUCTUAL Equivalence
#Average Cluster Method
cg.ase <- sna::equiv.clust(cg.stat,
equiv.fun = "sedist",
cluster.method = "average",
method = "hamming",
mode = "graph")
