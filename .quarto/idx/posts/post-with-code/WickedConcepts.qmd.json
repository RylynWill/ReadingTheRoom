{"title":"Wicked Concepts","markdown":{"yaml":{"title":"Wicked Concepts","author":"Rylyn Williams","format":{"html":{"df-print":"paged","embed-resources":true,"code-fold":true,"self-contained-math":true}}},"headingText":"Data wrangling","containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(warning = FALSE)\n```\n\n```{r include=FALSE}\nlibrary(tidyverse)\nlibrary(haven)\nlibrary(readr)\nlibrary(readxl)\nlibrary(tnet)\nlibrary(igraph)\nlibrary(statnet)\nlibrary(concoR)\nlibrary(GGally)\noptions(scipen=999)\n```\n\n```{r include=FALSE}\n#this funciton is to help with block modeling, as I will be using Eginvector Centrality.\nget.eigen<-function(net, attr=NULL){\n    #set attr=\"weight\" if weighted network\n    eigen<-sna::evcent(net)\n    mat<-as.matrix.network(net, attr=attr)\n    diag(mat)<-0\n    mat2<-mat%*%mat\n    rc<-diag(mat2)/rowSums(mat2)\n    dc<-1-rc\n    data.frame(name=net%v%\"vertex.names\",\n        eigen=eigen,\n        eigen.rc=eigen*rc,\n        eigen.dc=eigen*dc)\n}\n```\n\n```{r include=FALSE}\n#plotting block model\nplot.block<-function(x=blk_mod, main=NULL, cex.lab=1){\n  plot.sociomatrix(x$blocked.data, labels=list(x$plabels,x$plabels),\n                   main=main, drawlines = FALSE, cex.lab=cex.lab)\n  for (j in 2:length(x$plabels)) if (x$block.membership[j] !=\n                                     x$block.membership[j-1]) \n    abline(v = j - 0.5, h = j - 0.5, lty = 3, xpd=FALSE)\n}\n```\n\n\n```{r}\n#read in data tables from survey, 35 by 9 data table\nq1 <- read_csv(\"data/q1.csv\", show_col_types = FALSE)\nq2 <- read_csv(\"data/q2.csv\", show_col_types = FALSE)\nq3 <- read_csv(\"data/q3.csv\", show_col_types = FALSE)\nq4 <- read_csv(\"data/q4.csv\", show_col_types = FALSE)\nq5 <- read_csv(\"data/q5.csv\", show_col_types = FALSE )\n# remove total row so that it's 35 by 8, including column of concepts\nq1 <- select(q1, -9)\nq2 <- select(q2, -9)\nq3 <- select(q3, -9)\nq4 <- select(q4, -9)\nq5 <- select(q5, -9)\n\nhead(q1, 2)\nhead(q2, 2)\nhead(q3, 2)\nhead(q4, 2)\nhead(q5, 2)\n```\n\n```{r}\n# Join columns by term column, to create 35 by 35\nconcepts <- left_join(q1,q2,by=\"...1\")\nconcepts <- left_join(concepts,q3,by=\"...1\")\nconcepts <- left_join(concepts,q4,by=\"...1\")\nconcepts <- left_join(concepts,q5,by=\"...1\")\nconcepts <- select(concepts, -1)\nrownames(concepts)<-colnames(concepts)\nnamesss <- colnames(concepts)\n\n```\n`\n\n```{r}\nconcepts <- as.matrix(concepts)\n#replace NA's with Zero as the value is not missing, there is just no tie so there weight it 0\nconcepts[is.na(concepts)] <- 0\n# Set diag to false to remove self loops\ncg <- graph_from_adjacency_matrix(concepts)\n#Save the graph as a data frame that shows each ties and their weight.\ncg_frame <-get.data.frame(cg)\n```\n### Create a tnet object out of single counted actor ties, with weights being the count of the tie appearence\n```{r}\n#Identify unique vertices for the purpose of \nunique_vertices <- unique(c(cg_frame$from, cg_frame$to))\nvalid_vertices <- unique_vertices[!duplicated(unique_vertices) & nchar(unique_vertices) > 0]\n\n# Create an empty graph\ncg_graph <- graph(edges = numeric(0), directed = FALSE)\n\n# Add vertices to the graph\ncg_graph <- add_vertices(cg_graph, nv = length(valid_vertices), name = valid_vertices)\n\n# Count the occurrences of each unique tie\nties_count <- table(apply(cg_frame, 1, function(x) paste(sort(x), collapse = \"-\")))\n\n# Add subsequent ties of the same kind to the count of the first instance\nunique_ties <- unique(apply(cg_frame, 1, function(x) paste(sort(x), collapse = \"-\")))\nfor (tie in unique_ties) {\n  if (ties_count[tie] > 1) {\n    first_instance <- which(apply(cg_frame, 1, function(x) paste(sort(x), collapse = \"-\")) == tie)[1]\n    ties_count[tie] <- ties_count[tie] + (ties_count[tie] - 1)\n    ties_count[tie] <- ties_count[tie] - 1  # Subtract 1 because we're counting the first instance as unique\n  }\n}\n# Add vertices to the graph\ncg_graph <- add_vertices(cg_graph, nv = length(valid_vertices), name = valid_vertices)\n\n# Count the occurrences of each unique tie\nties_count <- table(apply(cg_frame, 1, function(x) paste(sort(x), collapse = \"-\")))\n\nunique_ties <- names(ties_count)\ntie_parts <- strsplit(unique_ties, \"-\")\nfrom_vertices <- sapply(tie_parts, `[`, 1)\nto_vertices <- sapply(tie_parts, `[`, 2)\nweights <- as.vector(ties_count)\n\n# Create a data frame\ncg_tie_df <- data.frame(from = from_vertices, to = to_vertices, weight = weights)\n\n# Print the data frame\nhead(cg_tie_df)\n```\n### creating tnet and statnet object\n```{r}\ncg_tie_df$from <- as.integer(as.factor(cg_tie_df$from))\ncg_tie_df$to <- as.integer(as.factor(cg_tie_df$to))\n\n# Create the network object\ncg_tnet <- as.tnet(cg_tie_df, type = \"weighted one-mode tnet\")\n\n```\n\n## Node-Level Measures\n\n```{r}\n#Out Degree/ out-strength \ncon.outdegree <- degree_w(cg_tnet, measure = c(\"degree\", \"output\"), type=\"out\", alpha = 1)\n#In Degree/ In-strength \ncon.indegree <- degree_w(cg_tnet, measure = c(\"degree\", \"output\"), type=\"in\", alpha = 1)\n#closeness\nc_close <- closeness_w(cg_tnet, directed =NULL, gconly = FALSE, alpha = 1)\n#betweeness\nc_btwn <- betweenness_w(cg_tnet, directed =NULL, alpha = 1)\n#constraints\n\n#Rename the columns because the function output names the columns the same regardless of the IN;Out status\ncolnames(con.outdegree)[2] <- \"Out-Strength\"\ncolnames(con.outdegree)[3] <- \"Out-Degree\"\ncolnames(con.indegree)[2] <- \"In-Strength\"\ncolnames(con.indegree)[3] <- \"In-Degree\"\n\n\n#Join the node measures to the same data frame\ncon.nodes <-left_join(as.data.frame(con.outdegree), as.data.frame(con.indegree), by= \"node\")\ncon.nodes <-left_join(as.data.frame(con.nodes), as.data.frame(c_close), by= \"node\")\ncon.nodes <-left_join(con.nodes, as.data.frame(c_btwn), by= \"node\")\n\n\n#temporary rename of node column to \"name\" to join the evigenor centrality for each nodes to the dataset and then \"node\" was replaced as the variable name for the nodes\ncolnames(con.nodes)[1] <- \"name\"\ncg.stat <- as.network.matrix(cg_tnet) \nset.vertex.attribute(cg.stat, \"name\",namesss) \ncon.nodes <- left_join(con.nodes, get.eigen(cg.stat), by = \"name\")\ncolnames(con.nodes)[1] <- \"node\"\n\n\nhead(con.nodes, 15)\n```\n\n## Strucutual Equivalnce\n\n```{r}\n#STRUCTUAL Equivalence \ncg.se <-equiv.clust(cg.stat,\n                          equiv.fun = \"sedist\",\n                          method = \"hamming\", \n                          mode = \"graph\")\nplot(cg.se,labels = cg.se$glabels)\n#Average Cluster Method\ncg.ase <- equiv.clust(cg.stat,\n                          equiv.fun = \"sedist\",\n                      cluster.method = \"average\",\n                          method = \"hamming\", \n                          mode = \"graph\")\nplot(cg.ase, cg.ase$glabels)\n\n#Single Cluster Method\ncg.sse<- equiv.clust(cg.stat,\n                          equiv.fun = \"sedist\",\n                      cluster.method = \"single\",\n                          method = \"hamming\", \n                          mode = \"graph\")\nplot(cg.sse,labels = cg.sse$glabels)\n\n# Ward.D method\ncg.wse<- equiv.clust(cg.stat,\n                          equiv.fun = \"sedist\",\n                      cluster.method = \"ward.D\",\n                          method = \"hamming\", \n                          mode = \"graph\")\nplot(cg.wse,labels = cg.wse$glabels)\n\n```\n\n## Partitioning\n\n### Height equal to 15\n\n```{r}\n#Partitioning regular clustering - 15\nplot(cg.se,labels = cg.se$glabels)\nrect.hclust(cg.se$cluster, h = 15)\n\n#Partitioning Average Cluster Method - 15\nplot(cg.ase,labels = cg.ase$glabels)\nrect.hclust(cg.ase$cluster, h = 15)\n\n#Partitioning Single Cluster Method - 15\nplot(cg.sse,labels = cg.sse$glabels)\nrect.hclust(cg.sse$cluster, h = 15)\n\n#Partitioning Ward.D method -15\nplot(cg.wse,labels = cg.wse$glabels)\nrect.hclust(cg.se$cluster, h = 15)\n```\n\n### Height equal to 10\n\n```{r}\n#Partitioning regular clustering -10\nplot(cg.se,labels = cg.se$glabels)\nrect.hclust(cg.se$cluster, h = 10)\n\n#Partitioning Average Cluster Method -10\nplot(cg.ase,labels = cg.ase$glabels)\nrect.hclust(cg.ase$cluster, h = 10)\n\n#Partitioning Single Cluster Method -10\nplot(cg.sse,labels = cg.sse$glabels)\nrect.hclust(cg.sse$cluster, h = 10)\n\n#Partitioning Ward.D method -10\nplot(cg.wse,labels = cg.wse$glabels)\nrect.hclust(cg.se$cluster, h = 10)\n```\n\n## BlockModeling\n\n### Height at 15 k=3\n\n```{r}\n#testing block model\nblock_se <-blockmodel(cg.stat, cg.se, k=3, h=15)\nblock_ase <-blockmodel(cg.stat, cg.ase, k=3, h=15)\nblock_sse <-blockmodel(cg.stat, cg.sse, k=3, h=15)\nblock_wse <-blockmodel(cg.stat, cg.wse, k=5, h=15) #tryin out 5\n\n#View models\nplot.block(block_se, cex.lab=.5)\nplot.block(block_ase, cex.lab=.5)\nplot.block(block_sse, cex.lab=.5)\nplot.block(block_wse, cex.lab=.5)\n```\n\n### Height at 10, k=3\n\n```{r}\n#testing block model\nblock_se <-blockmodel(cg.stat, cg.se, k=3, h=10)\nblock_ase <-blockmodel(cg.stat, cg.ase, k=3, h=10)\nblock_sse <-blockmodel(cg.stat, cg.sse, k=3, h=10)\nblock_wse <-blockmodel(cg.stat, cg.wse, k=5, h=10) #tryin out 5\n\n#View models\nplot.block(block_se, cex.lab=.5)\nplot.block(block_ase, cex.lab=.5)\nplot.block(block_sse, cex.lab=.5)\nplot.block(block_wse, cex.lab=.5)\n```\n\n## Let's Plot this\n\n### Statnet\n\n```{r}\n# chosen blockmodel and chose partition partitions\ncg_mod <- blockmodel(cg.stat, cg.se, k=5)\n# assign block membership to vertex attribute\ncg.stat%v%\"role\" <- cg_mod$block.membership[match(cg.stat%v%\"vertex.names\",\n                                                     cg_mod$plabels)]\n\nGGally::ggnet2(cg.stat,\n               node.color = \"role\",\n               node.size = degree(cg.stat, gmode = \"graph\"),\n               node.label = \"vertex.names\",\n               node.alpha = .7)\n```\n\n### igraph\n\n```{r}\ncg.ig <- graph_from_data_frame(cg_tnet)\nV(cg.ig)$role <- cg_mod$block.membership[match(V(cg.ig)$name, cg_mod$plabels)]\nplot.igraph(cg.ig,\n            vertex.color = V(cg.ig)$role,\n            vertex.size = 0.5+(igraph::degree(cg.ig)*0.5))\n```\n","srcMarkdownNoYaml":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(warning = FALSE)\n```\n\n```{r include=FALSE}\nlibrary(tidyverse)\nlibrary(haven)\nlibrary(readr)\nlibrary(readxl)\nlibrary(tnet)\nlibrary(igraph)\nlibrary(statnet)\nlibrary(concoR)\nlibrary(GGally)\noptions(scipen=999)\n```\n\n```{r include=FALSE}\n#this funciton is to help with block modeling, as I will be using Eginvector Centrality.\nget.eigen<-function(net, attr=NULL){\n    #set attr=\"weight\" if weighted network\n    eigen<-sna::evcent(net)\n    mat<-as.matrix.network(net, attr=attr)\n    diag(mat)<-0\n    mat2<-mat%*%mat\n    rc<-diag(mat2)/rowSums(mat2)\n    dc<-1-rc\n    data.frame(name=net%v%\"vertex.names\",\n        eigen=eigen,\n        eigen.rc=eigen*rc,\n        eigen.dc=eigen*dc)\n}\n```\n\n```{r include=FALSE}\n#plotting block model\nplot.block<-function(x=blk_mod, main=NULL, cex.lab=1){\n  plot.sociomatrix(x$blocked.data, labels=list(x$plabels,x$plabels),\n                   main=main, drawlines = FALSE, cex.lab=cex.lab)\n  for (j in 2:length(x$plabels)) if (x$block.membership[j] !=\n                                     x$block.membership[j-1]) \n    abline(v = j - 0.5, h = j - 0.5, lty = 3, xpd=FALSE)\n}\n```\n\n## Data wrangling\n\n```{r}\n#read in data tables from survey, 35 by 9 data table\nq1 <- read_csv(\"data/q1.csv\", show_col_types = FALSE)\nq2 <- read_csv(\"data/q2.csv\", show_col_types = FALSE)\nq3 <- read_csv(\"data/q3.csv\", show_col_types = FALSE)\nq4 <- read_csv(\"data/q4.csv\", show_col_types = FALSE)\nq5 <- read_csv(\"data/q5.csv\", show_col_types = FALSE )\n# remove total row so that it's 35 by 8, including column of concepts\nq1 <- select(q1, -9)\nq2 <- select(q2, -9)\nq3 <- select(q3, -9)\nq4 <- select(q4, -9)\nq5 <- select(q5, -9)\n\nhead(q1, 2)\nhead(q2, 2)\nhead(q3, 2)\nhead(q4, 2)\nhead(q5, 2)\n```\n\n```{r}\n# Join columns by term column, to create 35 by 35\nconcepts <- left_join(q1,q2,by=\"...1\")\nconcepts <- left_join(concepts,q3,by=\"...1\")\nconcepts <- left_join(concepts,q4,by=\"...1\")\nconcepts <- left_join(concepts,q5,by=\"...1\")\nconcepts <- select(concepts, -1)\nrownames(concepts)<-colnames(concepts)\nnamesss <- colnames(concepts)\n\n```\n`\n\n```{r}\nconcepts <- as.matrix(concepts)\n#replace NA's with Zero as the value is not missing, there is just no tie so there weight it 0\nconcepts[is.na(concepts)] <- 0\n# Set diag to false to remove self loops\ncg <- graph_from_adjacency_matrix(concepts)\n#Save the graph as a data frame that shows each ties and their weight.\ncg_frame <-get.data.frame(cg)\n```\n### Create a tnet object out of single counted actor ties, with weights being the count of the tie appearence\n```{r}\n#Identify unique vertices for the purpose of \nunique_vertices <- unique(c(cg_frame$from, cg_frame$to))\nvalid_vertices <- unique_vertices[!duplicated(unique_vertices) & nchar(unique_vertices) > 0]\n\n# Create an empty graph\ncg_graph <- graph(edges = numeric(0), directed = FALSE)\n\n# Add vertices to the graph\ncg_graph <- add_vertices(cg_graph, nv = length(valid_vertices), name = valid_vertices)\n\n# Count the occurrences of each unique tie\nties_count <- table(apply(cg_frame, 1, function(x) paste(sort(x), collapse = \"-\")))\n\n# Add subsequent ties of the same kind to the count of the first instance\nunique_ties <- unique(apply(cg_frame, 1, function(x) paste(sort(x), collapse = \"-\")))\nfor (tie in unique_ties) {\n  if (ties_count[tie] > 1) {\n    first_instance <- which(apply(cg_frame, 1, function(x) paste(sort(x), collapse = \"-\")) == tie)[1]\n    ties_count[tie] <- ties_count[tie] + (ties_count[tie] - 1)\n    ties_count[tie] <- ties_count[tie] - 1  # Subtract 1 because we're counting the first instance as unique\n  }\n}\n# Add vertices to the graph\ncg_graph <- add_vertices(cg_graph, nv = length(valid_vertices), name = valid_vertices)\n\n# Count the occurrences of each unique tie\nties_count <- table(apply(cg_frame, 1, function(x) paste(sort(x), collapse = \"-\")))\n\nunique_ties <- names(ties_count)\ntie_parts <- strsplit(unique_ties, \"-\")\nfrom_vertices <- sapply(tie_parts, `[`, 1)\nto_vertices <- sapply(tie_parts, `[`, 2)\nweights <- as.vector(ties_count)\n\n# Create a data frame\ncg_tie_df <- data.frame(from = from_vertices, to = to_vertices, weight = weights)\n\n# Print the data frame\nhead(cg_tie_df)\n```\n### creating tnet and statnet object\n```{r}\ncg_tie_df$from <- as.integer(as.factor(cg_tie_df$from))\ncg_tie_df$to <- as.integer(as.factor(cg_tie_df$to))\n\n# Create the network object\ncg_tnet <- as.tnet(cg_tie_df, type = \"weighted one-mode tnet\")\n\n```\n\n## Node-Level Measures\n\n```{r}\n#Out Degree/ out-strength \ncon.outdegree <- degree_w(cg_tnet, measure = c(\"degree\", \"output\"), type=\"out\", alpha = 1)\n#In Degree/ In-strength \ncon.indegree <- degree_w(cg_tnet, measure = c(\"degree\", \"output\"), type=\"in\", alpha = 1)\n#closeness\nc_close <- closeness_w(cg_tnet, directed =NULL, gconly = FALSE, alpha = 1)\n#betweeness\nc_btwn <- betweenness_w(cg_tnet, directed =NULL, alpha = 1)\n#constraints\n\n#Rename the columns because the function output names the columns the same regardless of the IN;Out status\ncolnames(con.outdegree)[2] <- \"Out-Strength\"\ncolnames(con.outdegree)[3] <- \"Out-Degree\"\ncolnames(con.indegree)[2] <- \"In-Strength\"\ncolnames(con.indegree)[3] <- \"In-Degree\"\n\n\n#Join the node measures to the same data frame\ncon.nodes <-left_join(as.data.frame(con.outdegree), as.data.frame(con.indegree), by= \"node\")\ncon.nodes <-left_join(as.data.frame(con.nodes), as.data.frame(c_close), by= \"node\")\ncon.nodes <-left_join(con.nodes, as.data.frame(c_btwn), by= \"node\")\n\n\n#temporary rename of node column to \"name\" to join the evigenor centrality for each nodes to the dataset and then \"node\" was replaced as the variable name for the nodes\ncolnames(con.nodes)[1] <- \"name\"\ncg.stat <- as.network.matrix(cg_tnet) \nset.vertex.attribute(cg.stat, \"name\",namesss) \ncon.nodes <- left_join(con.nodes, get.eigen(cg.stat), by = \"name\")\ncolnames(con.nodes)[1] <- \"node\"\n\n\nhead(con.nodes, 15)\n```\n\n## Strucutual Equivalnce\n\n```{r}\n#STRUCTUAL Equivalence \ncg.se <-equiv.clust(cg.stat,\n                          equiv.fun = \"sedist\",\n                          method = \"hamming\", \n                          mode = \"graph\")\nplot(cg.se,labels = cg.se$glabels)\n#Average Cluster Method\ncg.ase <- equiv.clust(cg.stat,\n                          equiv.fun = \"sedist\",\n                      cluster.method = \"average\",\n                          method = \"hamming\", \n                          mode = \"graph\")\nplot(cg.ase, cg.ase$glabels)\n\n#Single Cluster Method\ncg.sse<- equiv.clust(cg.stat,\n                          equiv.fun = \"sedist\",\n                      cluster.method = \"single\",\n                          method = \"hamming\", \n                          mode = \"graph\")\nplot(cg.sse,labels = cg.sse$glabels)\n\n# Ward.D method\ncg.wse<- equiv.clust(cg.stat,\n                          equiv.fun = \"sedist\",\n                      cluster.method = \"ward.D\",\n                          method = \"hamming\", \n                          mode = \"graph\")\nplot(cg.wse,labels = cg.wse$glabels)\n\n```\n\n## Partitioning\n\n### Height equal to 15\n\n```{r}\n#Partitioning regular clustering - 15\nplot(cg.se,labels = cg.se$glabels)\nrect.hclust(cg.se$cluster, h = 15)\n\n#Partitioning Average Cluster Method - 15\nplot(cg.ase,labels = cg.ase$glabels)\nrect.hclust(cg.ase$cluster, h = 15)\n\n#Partitioning Single Cluster Method - 15\nplot(cg.sse,labels = cg.sse$glabels)\nrect.hclust(cg.sse$cluster, h = 15)\n\n#Partitioning Ward.D method -15\nplot(cg.wse,labels = cg.wse$glabels)\nrect.hclust(cg.se$cluster, h = 15)\n```\n\n### Height equal to 10\n\n```{r}\n#Partitioning regular clustering -10\nplot(cg.se,labels = cg.se$glabels)\nrect.hclust(cg.se$cluster, h = 10)\n\n#Partitioning Average Cluster Method -10\nplot(cg.ase,labels = cg.ase$glabels)\nrect.hclust(cg.ase$cluster, h = 10)\n\n#Partitioning Single Cluster Method -10\nplot(cg.sse,labels = cg.sse$glabels)\nrect.hclust(cg.sse$cluster, h = 10)\n\n#Partitioning Ward.D method -10\nplot(cg.wse,labels = cg.wse$glabels)\nrect.hclust(cg.se$cluster, h = 10)\n```\n\n## BlockModeling\n\n### Height at 15 k=3\n\n```{r}\n#testing block model\nblock_se <-blockmodel(cg.stat, cg.se, k=3, h=15)\nblock_ase <-blockmodel(cg.stat, cg.ase, k=3, h=15)\nblock_sse <-blockmodel(cg.stat, cg.sse, k=3, h=15)\nblock_wse <-blockmodel(cg.stat, cg.wse, k=5, h=15) #tryin out 5\n\n#View models\nplot.block(block_se, cex.lab=.5)\nplot.block(block_ase, cex.lab=.5)\nplot.block(block_sse, cex.lab=.5)\nplot.block(block_wse, cex.lab=.5)\n```\n\n### Height at 10, k=3\n\n```{r}\n#testing block model\nblock_se <-blockmodel(cg.stat, cg.se, k=3, h=10)\nblock_ase <-blockmodel(cg.stat, cg.ase, k=3, h=10)\nblock_sse <-blockmodel(cg.stat, cg.sse, k=3, h=10)\nblock_wse <-blockmodel(cg.stat, cg.wse, k=5, h=10) #tryin out 5\n\n#View models\nplot.block(block_se, cex.lab=.5)\nplot.block(block_ase, cex.lab=.5)\nplot.block(block_sse, cex.lab=.5)\nplot.block(block_wse, cex.lab=.5)\n```\n\n## Let's Plot this\n\n### Statnet\n\n```{r}\n# chosen blockmodel and chose partition partitions\ncg_mod <- blockmodel(cg.stat, cg.se, k=5)\n# assign block membership to vertex attribute\ncg.stat%v%\"role\" <- cg_mod$block.membership[match(cg.stat%v%\"vertex.names\",\n                                                     cg_mod$plabels)]\n\nGGally::ggnet2(cg.stat,\n               node.color = \"role\",\n               node.size = degree(cg.stat, gmode = \"graph\"),\n               node.label = \"vertex.names\",\n               node.alpha = .7)\n```\n\n### igraph\n\n```{r}\ncg.ig <- graph_from_data_frame(cg_tnet)\nV(cg.ig)$role <- cg_mod$block.membership[match(V(cg.ig)$name, cg_mod$plabels)]\nplot.igraph(cg.ig,\n            vertex.color = V(cg.ig)$role,\n            vertex.size = 0.5+(igraph::degree(cg.ig)*0.5))\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":true,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"embed-resources":true,"output-file":"WickedConcepts.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","editor":"visual","theme":"sketchy","title-block-banner":true,"title":"Wicked Concepts","author":"Rylyn Williams"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}