[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/post-with-code/RolesandPartions.html",
    "href": "posts/post-with-code/RolesandPartions.html",
    "title": "Plots by Roles",
    "section": "",
    "text": "Code\n#read in data tables from survey, 35 by 9 data table\nq1 &lt;- read_csv(\"data/q1.csv\", show_col_types = FALSE)\n\n\nNew names:\n• `` -&gt; `...1`\n\n\nCode\nq2 &lt;- read_csv(\"data/q2.csv\", show_col_types = FALSE)\n\n\nNew names:\n• `` -&gt; `...1`\n\n\nCode\nq3 &lt;- read_csv(\"data/q3.csv\", show_col_types = FALSE)\n\n\nNew names:\n• `` -&gt; `...1`\n\n\nCode\nq4 &lt;- read_csv(\"data/q4.csv\", show_col_types = FALSE)\n\n\nNew names:\n• `` -&gt; `...1`\n\n\nCode\nq5 &lt;- read_csv(\"data/q5.csv\", show_col_types = FALSE )\n\n\nNew names:\n• `` -&gt; `...1`\n\n\nCode\n# remove total row so that it's 35 by 8, including column of concepts\nq1 &lt;- select(q1, -9)\nq2 &lt;- select(q2, -9)\nq3 &lt;- select(q3, -9)\nq4 &lt;- select(q4, -9)\nq5 &lt;- select(q5, -9)\n\nhead(q1, 2)\n\n\n\n  \n\n\n\nCode\nhead(q2, 2)\n\n\n\n  \n\n\n\nCode\nhead(q3, 2)\n\n\n\n  \n\n\n\nCode\nhead(q4, 2)\n\n\n\n  \n\n\n\nCode\nhead(q5, 2)\n\n\n\n  \n\n\n\n\n\nCode\n# Join columns by term column, to create 35 by 35\nconcepts &lt;- left_join(q1,q2,by=\"...1\")\nconcepts &lt;- left_join(concepts,q3,by=\"...1\")\nconcepts &lt;- left_join(concepts,q4,by=\"...1\")\nconcepts &lt;- left_join(concepts,q5,by=\"...1\")\nconcepts &lt;- select(concepts, -1)\nrownames(concepts)&lt;-colnames(concepts)\n\n\n`\n\n\nCode\nconcepts &lt;- as.matrix(concepts)\n#replace NA's with Zero as the value is not missing, there is just no tie so there weight it 0\nconcepts[is.na(concepts)] &lt;- 0\n# Set diag to false to remove self loops\ncg &lt;- graph_from_adjacency_matrix(concepts)\n#Save the graph as a data frame that shows each ties and their weight.\ncg_frame &lt;-get.data.frame(cg)\n\n\n\n\n\n\nCode\n# Identify unique vertices, I want the definition of a tie, to be the first instance of that connection.\nunique_vertices &lt;- unique(c(cg_frame$from, cg_frame$to))\nvalid_vertices &lt;- unique_vertices[nchar(unique_vertices) &gt; 0]\n\n# Create an empty graph\ncg_graph &lt;- graph(edges = numeric(0), directed = FALSE)\n\n# Add vertices to the graph\ncg_graph &lt;- add_vertices(cg_graph, nv = length(valid_vertices), name = valid_vertices)\n\n# Count tie occurrences, the number of times that tie occurs, will be it's strength/weight\nties_count &lt;- table(apply(cg_frame, 1, function(x) paste(sort(x), collapse = \"-\")))\n\n# Adjust tie counts for subsequent ties # this will count reverse tiess so B to A where the code above check A to B\nunique_ties &lt;- unique(apply(cg_frame, 1, function(x) paste(sort(x), collapse = \"-\")))\nfor (tie in unique_ties) {\n  ties_count[tie] &lt;- ifelse(ties_count[tie] &gt; 1, ties_count[tie], ties_count[tie] + 1)\n}\n\n# Process ties data\ntie_parts &lt;- strsplit(names(ties_count), \"-\")\nfrom_vertices &lt;- sapply(tie_parts, `[`, 1)\nto_vertices &lt;- sapply(tie_parts, `[`, 2)\nweights &lt;- as.vector(ties_count)\n\n# Create a data frame\ncg_tie_df &lt;- data.frame(from = from_vertices, to = to_vertices, weight = weights)\n\n# Print the data frame\nhead(cg_tie_df)\n\n\n\n  \n\n\n\n\n\n\n\n\nCode\ncg_tie_df$from &lt;- as.integer(as.factor(cg_tie_df$from))\ncg_tie_df$to &lt;- as.integer(as.factor(cg_tie_df$to))\n\n# Create the network object\ncg_tnet &lt;- as.tnet(cg_tie_df, type = \"weighted one-mode tnet\")\ncg.ig &lt;- tnet_igraph(cg_tnet, type = \"weighted one-mode tnet\", directed = NULL)\ncg.ig&lt;- add_vertices(cg.ig, nv = length(valid_vertices), name = valid_vertices)\nnamesss &lt;-data.frame(id = 1:35, node = colnames(concepts))\ncg.stat &lt;- as.network.matrix(cg_tnet)\nnetwork.vertex.names(cg.stat) &lt;- namesss$node"
  },
  {
    "objectID": "posts/post-with-code/RolesandPartions.html#data-wrangling",
    "href": "posts/post-with-code/RolesandPartions.html#data-wrangling",
    "title": "Plots by Roles",
    "section": "",
    "text": "Code\n#read in data tables from survey, 35 by 9 data table\nq1 &lt;- read_csv(\"data/q1.csv\", show_col_types = FALSE)\n\n\nNew names:\n• `` -&gt; `...1`\n\n\nCode\nq2 &lt;- read_csv(\"data/q2.csv\", show_col_types = FALSE)\n\n\nNew names:\n• `` -&gt; `...1`\n\n\nCode\nq3 &lt;- read_csv(\"data/q3.csv\", show_col_types = FALSE)\n\n\nNew names:\n• `` -&gt; `...1`\n\n\nCode\nq4 &lt;- read_csv(\"data/q4.csv\", show_col_types = FALSE)\n\n\nNew names:\n• `` -&gt; `...1`\n\n\nCode\nq5 &lt;- read_csv(\"data/q5.csv\", show_col_types = FALSE )\n\n\nNew names:\n• `` -&gt; `...1`\n\n\nCode\n# remove total row so that it's 35 by 8, including column of concepts\nq1 &lt;- select(q1, -9)\nq2 &lt;- select(q2, -9)\nq3 &lt;- select(q3, -9)\nq4 &lt;- select(q4, -9)\nq5 &lt;- select(q5, -9)\n\nhead(q1, 2)\n\n\n\n  \n\n\n\nCode\nhead(q2, 2)\n\n\n\n  \n\n\n\nCode\nhead(q3, 2)\n\n\n\n  \n\n\n\nCode\nhead(q4, 2)\n\n\n\n  \n\n\n\nCode\nhead(q5, 2)\n\n\n\n  \n\n\n\n\n\nCode\n# Join columns by term column, to create 35 by 35\nconcepts &lt;- left_join(q1,q2,by=\"...1\")\nconcepts &lt;- left_join(concepts,q3,by=\"...1\")\nconcepts &lt;- left_join(concepts,q4,by=\"...1\")\nconcepts &lt;- left_join(concepts,q5,by=\"...1\")\nconcepts &lt;- select(concepts, -1)\nrownames(concepts)&lt;-colnames(concepts)\n\n\n`\n\n\nCode\nconcepts &lt;- as.matrix(concepts)\n#replace NA's with Zero as the value is not missing, there is just no tie so there weight it 0\nconcepts[is.na(concepts)] &lt;- 0\n# Set diag to false to remove self loops\ncg &lt;- graph_from_adjacency_matrix(concepts)\n#Save the graph as a data frame that shows each ties and their weight.\ncg_frame &lt;-get.data.frame(cg)\n\n\n\n\n\n\nCode\n# Identify unique vertices, I want the definition of a tie, to be the first instance of that connection.\nunique_vertices &lt;- unique(c(cg_frame$from, cg_frame$to))\nvalid_vertices &lt;- unique_vertices[nchar(unique_vertices) &gt; 0]\n\n# Create an empty graph\ncg_graph &lt;- graph(edges = numeric(0), directed = FALSE)\n\n# Add vertices to the graph\ncg_graph &lt;- add_vertices(cg_graph, nv = length(valid_vertices), name = valid_vertices)\n\n# Count tie occurrences, the number of times that tie occurs, will be it's strength/weight\nties_count &lt;- table(apply(cg_frame, 1, function(x) paste(sort(x), collapse = \"-\")))\n\n# Adjust tie counts for subsequent ties # this will count reverse tiess so B to A where the code above check A to B\nunique_ties &lt;- unique(apply(cg_frame, 1, function(x) paste(sort(x), collapse = \"-\")))\nfor (tie in unique_ties) {\n  ties_count[tie] &lt;- ifelse(ties_count[tie] &gt; 1, ties_count[tie], ties_count[tie] + 1)\n}\n\n# Process ties data\ntie_parts &lt;- strsplit(names(ties_count), \"-\")\nfrom_vertices &lt;- sapply(tie_parts, `[`, 1)\nto_vertices &lt;- sapply(tie_parts, `[`, 2)\nweights &lt;- as.vector(ties_count)\n\n# Create a data frame\ncg_tie_df &lt;- data.frame(from = from_vertices, to = to_vertices, weight = weights)\n\n# Print the data frame\nhead(cg_tie_df)\n\n\n\n  \n\n\n\n\n\n\n\n\nCode\ncg_tie_df$from &lt;- as.integer(as.factor(cg_tie_df$from))\ncg_tie_df$to &lt;- as.integer(as.factor(cg_tie_df$to))\n\n# Create the network object\ncg_tnet &lt;- as.tnet(cg_tie_df, type = \"weighted one-mode tnet\")\ncg.ig &lt;- tnet_igraph(cg_tnet, type = \"weighted one-mode tnet\", directed = NULL)\ncg.ig&lt;- add_vertices(cg.ig, nv = length(valid_vertices), name = valid_vertices)\nnamesss &lt;-data.frame(id = 1:35, node = colnames(concepts))\ncg.stat &lt;- as.network.matrix(cg_tnet)\nnetwork.vertex.names(cg.stat) &lt;- namesss$node"
  },
  {
    "objectID": "posts/post-with-code/RolesandPartions.html#node-level-measures",
    "href": "posts/post-with-code/RolesandPartions.html#node-level-measures",
    "title": "Plots by Roles",
    "section": "Node-Level Measures",
    "text": "Node-Level Measures\n\n\nCode\n#get betweennes, power centrailitty, degree strength (based on weights), closeness, and constraints\ncg.nodes&lt;-data.frame(name=cg.stat%v%\"vertex.names\",\n        degree.wt=igraph::strength(cg.ig),\n        power.cent =igraph::power_centrality(cg.ig),\n        betweenness=sna::betweenness(cg.stat, gmode=\"graph\"),\n        close=sna::closeness(cg.stat, gmode=\"graph\"),\n        constraint=igraph::constraint(cg.ig))\neigen_cent_df &lt;- as.data.frame(eigen_centrality(cg.ig))\neigen_cent_df &lt;- head(eigen_cent_df,35)\ncg.nodes&lt;-cbind(cg.nodes, eigen_cent_df)\ncg.nodes &lt;- head(cg.nodes,35) # don't care about place holder empty columns,\ncg.nodes &lt;- cg.nodes[, 1:8]\nhead(cg.nodes, 6)"
  },
  {
    "objectID": "posts/post-with-code/RolesandPartions.html#strucutual-equivalnce",
    "href": "posts/post-with-code/RolesandPartions.html#strucutual-equivalnce",
    "title": "Plots by Roles",
    "section": "Strucutual Equivalnce",
    "text": "Strucutual Equivalnce\n\n\nCode\n#STRUCTUAL Equivalence \n#Average Cluster Method\ncg.ase &lt;- sna::equiv.clust(cg.stat,\n                          equiv.fun = \"sedist\",\n                      cluster.method = \"average\",\n                          method = \"hamming\", \n                          mode = \"graph\")\nplot(cg.ase, cg.ase$glabels)"
  },
  {
    "objectID": "posts/post-with-code/RolesandPartions.html#partitioning",
    "href": "posts/post-with-code/RolesandPartions.html#partitioning",
    "title": "Plots by Roles",
    "section": "Partitioning",
    "text": "Partitioning\n\nHeight equal to 10\n\n\nCode\n#Partitioning Average Cluster Method -5\nplot(cg.ase,labels = cg.ase$glabels)\nrect.hclust(cg.ase$cluster, h = 5)"
  },
  {
    "objectID": "posts/post-with-code/RolesandPartions.html#blockmodeling",
    "href": "posts/post-with-code/RolesandPartions.html#blockmodeling",
    "title": "Plots by Roles",
    "section": "BlockModeling",
    "text": "BlockModeling\n\n\nCode\n#testing block model\nblock_ase &lt;-blockmodel(cg.stat, cg.ase, k=9, h=5) #tryin out 5\n#View model\nplot.block(block_ase, cex.lab=.5)"
  },
  {
    "objectID": "posts/post-with-code/RolesandPartions.html#centrality-by-role",
    "href": "posts/post-with-code/RolesandPartions.html#centrality-by-role",
    "title": "Plots by Roles",
    "section": "Centrality by Role",
    "text": "Centrality by Role\n\n\nCode\nblk_mod &lt;- blockmodel(cg.stat, cg.ase, k=9)\n# assign block membership to vertex attribute\ncg.stat%v%\"role\" &lt;- blk_mod$block.membership[match(cg.stat%v%\"vertex.names\",\n                                                     blk_mod$plabels)]\n\n\n# attach\ncg.nodes$role &lt;- cg.stat%v%\"role\"\n\n# summarize various network statistics by role\ncg.nodes %&gt;%\n  select(-name) %&gt;%\n  group_by(role) %&gt;%\n  mutate(n=n()) %&gt;%\n  summarise_all(mean, na.rm = TRUE) %&gt;%\n  as.matrix() %&gt;%\n  print(digits=2)\n\n\n      role degree.wt    power.cent betweenness close constraint vector value n\n [1,]    1       376 3.39641642476       0.000  1.00       0.12   0.73   361 4\n [2,]    2       357 0.21227602615       0.000  1.00       0.12   0.69   361 4\n [3,]    3       369 0.01096759428       0.000  1.00       0.12   0.72   361 5\n [4,]    4       340 0.00051594822       0.018  0.99       0.12   0.67   361 3\n [5,]    5       300 0.00005182480       0.026  1.00       0.12   0.59   361 4\n [6,]    6       370 0.00000323865       0.026  1.00       0.12   0.72   361 4\n [7,]    7       333 0.00000020202       0.026  1.00       0.12   0.65   361 4\n [8,]    8       367 0.00000001004       0.026  1.00       0.12   0.71   361 5\n [9,]    9       262 0.00000000021       0.000  0.99       0.12   0.52   361 2\n\n\n\n\nCode\n# chosen blockmodel and chose partition partitions\ncg_mod &lt;- blockmodel(cg.stat, cg.ase, k=9)\n# assign block membership to vertex attribute\ncg.stat%v%\"role\" &lt;- cg_mod$block.membership[match(cg.stat%v%\"vertex.names\",\n                                                     cg_mod$plabels)]\n\nGGally::ggnet2(cg.stat,\n               node.color = \"role\",\n               node.size = degree(cg.stat, gmode = \"graph\"),\n               node.label = \"vertex.names\",\n               node.alpha = .7)\n\n\n\n\n\n\n\n\n\n`"
  },
  {
    "objectID": "posts/post-with-code/WickedConcepts.html",
    "href": "posts/post-with-code/WickedConcepts.html",
    "title": "Wicked Concepts",
    "section": "",
    "text": "Code\n#read in data tables from survey, 35 by 9 data table\nq1 &lt;- read_csv(\"data/q1.csv\", show_col_types = FALSE)\n\n\nNew names:\n• `` -&gt; `...1`\n\n\nCode\nq2 &lt;- read_csv(\"data/q2.csv\", show_col_types = FALSE)\n\n\nNew names:\n• `` -&gt; `...1`\n\n\nCode\nq3 &lt;- read_csv(\"data/q3.csv\", show_col_types = FALSE)\n\n\nNew names:\n• `` -&gt; `...1`\n\n\nCode\nq4 &lt;- read_csv(\"data/q4.csv\", show_col_types = FALSE)\n\n\nNew names:\n• `` -&gt; `...1`\n\n\nCode\nq5 &lt;- read_csv(\"data/q5.csv\", show_col_types = FALSE )\n\n\nNew names:\n• `` -&gt; `...1`\n\n\nCode\n# remove total row so that it's 35 by 8, including column of concepts\nq1 &lt;- select(q1, -9)\nq2 &lt;- select(q2, -9)\nq3 &lt;- select(q3, -9)\nq4 &lt;- select(q4, -9)\nq5 &lt;- select(q5, -9)\n\nhead(q1, 2)\n\n\n\n  \n\n\n\nCode\nhead(q2, 2)\n\n\n\n  \n\n\n\nCode\nhead(q3, 2)\n\n\n\n  \n\n\n\nCode\nhead(q4, 2)\n\n\n\n  \n\n\n\nCode\nhead(q5, 2)\n\n\n\n  \n\n\n\n\n\nCode\n# Join columns by term column, to create 35 by 35\nconcepts &lt;- left_join(q1,q2,by=\"...1\")\nconcepts &lt;- left_join(concepts,q3,by=\"...1\")\nconcepts &lt;- left_join(concepts,q4,by=\"...1\")\nconcepts &lt;- left_join(concepts,q5,by=\"...1\")\nconcepts &lt;- select(concepts, -1)\nrownames(concepts)&lt;-colnames(concepts)\nnamesss &lt;- colnames(concepts)\n\n\n`\n\n\nCode\nconcepts &lt;- as.matrix(concepts)\n#replace NA's with Zero as the value is not missing, there is just no tie so there weight it 0\nconcepts[is.na(concepts)] &lt;- 0\n# Set diag to false to remove self loops\ncg &lt;- graph_from_adjacency_matrix(concepts)\n#Save the graph as a data frame that shows each ties and their weight.\ncg_frame &lt;-get.data.frame(cg)\n\n\n\n\n\n\nCode\n#Identify unique vertices for the purpose of \nunique_vertices &lt;- unique(c(cg_frame$from, cg_frame$to))\nvalid_vertices &lt;- unique_vertices[!duplicated(unique_vertices) & nchar(unique_vertices) &gt; 0]\n\n# Create an empty graph\ncg_graph &lt;- graph(edges = numeric(0), directed = FALSE)\n\n# Add vertices to the graph\ncg_graph &lt;- add_vertices(cg_graph, nv = length(valid_vertices), name = valid_vertices)\n\n# Count the occurrences of each unique tie\nties_count &lt;- table(apply(cg_frame, 1, function(x) paste(sort(x), collapse = \"-\")))\n\n# Add subsequent ties of the same kind to the count of the first instance\nunique_ties &lt;- unique(apply(cg_frame, 1, function(x) paste(sort(x), collapse = \"-\")))\nfor (tie in unique_ties) {\n  if (ties_count[tie] &gt; 1) {\n    first_instance &lt;- which(apply(cg_frame, 1, function(x) paste(sort(x), collapse = \"-\")) == tie)[1]\n    ties_count[tie] &lt;- ties_count[tie] + (ties_count[tie] - 1)\n    ties_count[tie] &lt;- ties_count[tie] - 1  # Subtract 1 because we're counting the first instance as unique\n  }\n}\n# Add vertices to the graph\ncg_graph &lt;- add_vertices(cg_graph, nv = length(valid_vertices), name = valid_vertices)\n\n# Count the occurrences of each unique tie\nties_count &lt;- table(apply(cg_frame, 1, function(x) paste(sort(x), collapse = \"-\")))\n\nunique_ties &lt;- names(ties_count)\ntie_parts &lt;- strsplit(unique_ties, \"-\")\nfrom_vertices &lt;- sapply(tie_parts, `[`, 1)\nto_vertices &lt;- sapply(tie_parts, `[`, 2)\nweights &lt;- as.vector(ties_count)\n\n# Create a data frame\ncg_tie_df &lt;- data.frame(from = from_vertices, to = to_vertices, weight = weights)\n\n# Print the data frame\nhead(cg_tie_df)\n\n\n\n  \n\n\n\n\n\n\n\n\nCode\ncg_tie_df$from &lt;- as.integer(as.factor(cg_tie_df$from))\ncg_tie_df$to &lt;- as.integer(as.factor(cg_tie_df$to))\n\n# Create the network object\ncg_tnet &lt;- as.tnet(cg_tie_df, type = \"weighted one-mode tnet\")"
  },
  {
    "objectID": "posts/post-with-code/WickedConcepts.html#data-wrangling",
    "href": "posts/post-with-code/WickedConcepts.html#data-wrangling",
    "title": "Wicked Concepts",
    "section": "",
    "text": "Code\n#read in data tables from survey, 35 by 9 data table\nq1 &lt;- read_csv(\"data/q1.csv\", show_col_types = FALSE)\n\n\nNew names:\n• `` -&gt; `...1`\n\n\nCode\nq2 &lt;- read_csv(\"data/q2.csv\", show_col_types = FALSE)\n\n\nNew names:\n• `` -&gt; `...1`\n\n\nCode\nq3 &lt;- read_csv(\"data/q3.csv\", show_col_types = FALSE)\n\n\nNew names:\n• `` -&gt; `...1`\n\n\nCode\nq4 &lt;- read_csv(\"data/q4.csv\", show_col_types = FALSE)\n\n\nNew names:\n• `` -&gt; `...1`\n\n\nCode\nq5 &lt;- read_csv(\"data/q5.csv\", show_col_types = FALSE )\n\n\nNew names:\n• `` -&gt; `...1`\n\n\nCode\n# remove total row so that it's 35 by 8, including column of concepts\nq1 &lt;- select(q1, -9)\nq2 &lt;- select(q2, -9)\nq3 &lt;- select(q3, -9)\nq4 &lt;- select(q4, -9)\nq5 &lt;- select(q5, -9)\n\nhead(q1, 2)\n\n\n\n  \n\n\n\nCode\nhead(q2, 2)\n\n\n\n  \n\n\n\nCode\nhead(q3, 2)\n\n\n\n  \n\n\n\nCode\nhead(q4, 2)\n\n\n\n  \n\n\n\nCode\nhead(q5, 2)\n\n\n\n  \n\n\n\n\n\nCode\n# Join columns by term column, to create 35 by 35\nconcepts &lt;- left_join(q1,q2,by=\"...1\")\nconcepts &lt;- left_join(concepts,q3,by=\"...1\")\nconcepts &lt;- left_join(concepts,q4,by=\"...1\")\nconcepts &lt;- left_join(concepts,q5,by=\"...1\")\nconcepts &lt;- select(concepts, -1)\nrownames(concepts)&lt;-colnames(concepts)\nnamesss &lt;- colnames(concepts)\n\n\n`\n\n\nCode\nconcepts &lt;- as.matrix(concepts)\n#replace NA's with Zero as the value is not missing, there is just no tie so there weight it 0\nconcepts[is.na(concepts)] &lt;- 0\n# Set diag to false to remove self loops\ncg &lt;- graph_from_adjacency_matrix(concepts)\n#Save the graph as a data frame that shows each ties and their weight.\ncg_frame &lt;-get.data.frame(cg)\n\n\n\n\n\n\nCode\n#Identify unique vertices for the purpose of \nunique_vertices &lt;- unique(c(cg_frame$from, cg_frame$to))\nvalid_vertices &lt;- unique_vertices[!duplicated(unique_vertices) & nchar(unique_vertices) &gt; 0]\n\n# Create an empty graph\ncg_graph &lt;- graph(edges = numeric(0), directed = FALSE)\n\n# Add vertices to the graph\ncg_graph &lt;- add_vertices(cg_graph, nv = length(valid_vertices), name = valid_vertices)\n\n# Count the occurrences of each unique tie\nties_count &lt;- table(apply(cg_frame, 1, function(x) paste(sort(x), collapse = \"-\")))\n\n# Add subsequent ties of the same kind to the count of the first instance\nunique_ties &lt;- unique(apply(cg_frame, 1, function(x) paste(sort(x), collapse = \"-\")))\nfor (tie in unique_ties) {\n  if (ties_count[tie] &gt; 1) {\n    first_instance &lt;- which(apply(cg_frame, 1, function(x) paste(sort(x), collapse = \"-\")) == tie)[1]\n    ties_count[tie] &lt;- ties_count[tie] + (ties_count[tie] - 1)\n    ties_count[tie] &lt;- ties_count[tie] - 1  # Subtract 1 because we're counting the first instance as unique\n  }\n}\n# Add vertices to the graph\ncg_graph &lt;- add_vertices(cg_graph, nv = length(valid_vertices), name = valid_vertices)\n\n# Count the occurrences of each unique tie\nties_count &lt;- table(apply(cg_frame, 1, function(x) paste(sort(x), collapse = \"-\")))\n\nunique_ties &lt;- names(ties_count)\ntie_parts &lt;- strsplit(unique_ties, \"-\")\nfrom_vertices &lt;- sapply(tie_parts, `[`, 1)\nto_vertices &lt;- sapply(tie_parts, `[`, 2)\nweights &lt;- as.vector(ties_count)\n\n# Create a data frame\ncg_tie_df &lt;- data.frame(from = from_vertices, to = to_vertices, weight = weights)\n\n# Print the data frame\nhead(cg_tie_df)\n\n\n\n  \n\n\n\n\n\n\n\n\nCode\ncg_tie_df$from &lt;- as.integer(as.factor(cg_tie_df$from))\ncg_tie_df$to &lt;- as.integer(as.factor(cg_tie_df$to))\n\n# Create the network object\ncg_tnet &lt;- as.tnet(cg_tie_df, type = \"weighted one-mode tnet\")"
  },
  {
    "objectID": "posts/post-with-code/WickedConcepts.html#node-level-measures",
    "href": "posts/post-with-code/WickedConcepts.html#node-level-measures",
    "title": "Wicked Concepts",
    "section": "Node-Level Measures",
    "text": "Node-Level Measures\n\n\nCode\n#Out Degree/ out-strength \ncon.outdegree &lt;- degree_w(cg_tnet, measure = c(\"degree\", \"output\"), type=\"out\", alpha = 1)\n#In Degree/ In-strength \ncon.indegree &lt;- degree_w(cg_tnet, measure = c(\"degree\", \"output\"), type=\"in\", alpha = 1)\n#closeness\nc_close &lt;- closeness_w(cg_tnet, directed =NULL, gconly = FALSE, alpha = 1)\n#betweeness\nc_btwn &lt;- betweenness_w(cg_tnet, directed =NULL, alpha = 1)\n#constraints\n\n#Rename the columns because the function output names the columns the same regardless of the IN;Out status\ncolnames(con.outdegree)[2] &lt;- \"Out-Strength\"\ncolnames(con.outdegree)[3] &lt;- \"Out-Degree\"\ncolnames(con.indegree)[2] &lt;- \"In-Strength\"\ncolnames(con.indegree)[3] &lt;- \"In-Degree\"\n\n\n#Join the node measures to the same data frame\ncon.nodes &lt;-left_join(as.data.frame(con.outdegree), as.data.frame(con.indegree), by= \"node\")\ncon.nodes &lt;-left_join(as.data.frame(con.nodes), as.data.frame(c_close), by= \"node\")\ncon.nodes &lt;-left_join(con.nodes, as.data.frame(c_btwn), by= \"node\")\n\n\n#temporary rename of node column to \"name\" to join the evigenor centrality for each nodes to the dataset and then \"node\" was replaced as the variable name for the nodes\ncolnames(con.nodes)[1] &lt;- \"name\"\ncg.stat &lt;- as.network.matrix(cg_tnet) \nset.vertex.attribute(cg.stat, \"name\",namesss) \ncon.nodes &lt;- left_join(con.nodes, get.eigen(cg.stat), by = \"name\")\ncolnames(con.nodes)[1] &lt;- \"node\"\n\n\nhead(con.nodes, 15)"
  },
  {
    "objectID": "posts/post-with-code/WickedConcepts.html#strucutual-equivalnce",
    "href": "posts/post-with-code/WickedConcepts.html#strucutual-equivalnce",
    "title": "Wicked Concepts",
    "section": "Strucutual Equivalnce",
    "text": "Strucutual Equivalnce\n\n\nCode\n#STRUCTUAL Equivalence \ncg.se &lt;-equiv.clust(cg.stat,\n                          equiv.fun = \"sedist\",\n                          method = \"hamming\", \n                          mode = \"graph\")\nplot(cg.se,labels = cg.se$glabels)\n\n\n\n\n\n\n\n\n\nCode\n#Average Cluster Method\ncg.ase &lt;- equiv.clust(cg.stat,\n                          equiv.fun = \"sedist\",\n                      cluster.method = \"average\",\n                          method = \"hamming\", \n                          mode = \"graph\")\nplot(cg.ase, cg.ase$glabels)\n\n\n\n\n\n\n\n\n\nCode\n#Single Cluster Method\ncg.sse&lt;- equiv.clust(cg.stat,\n                          equiv.fun = \"sedist\",\n                      cluster.method = \"single\",\n                          method = \"hamming\", \n                          mode = \"graph\")\nplot(cg.sse,labels = cg.sse$glabels)\n\n\n\n\n\n\n\n\n\nCode\n# Ward.D method\ncg.wse&lt;- equiv.clust(cg.stat,\n                          equiv.fun = \"sedist\",\n                      cluster.method = \"ward.D\",\n                          method = \"hamming\", \n                          mode = \"graph\")\nplot(cg.wse,labels = cg.wse$glabels)"
  },
  {
    "objectID": "posts/post-with-code/WickedConcepts.html#partitioning",
    "href": "posts/post-with-code/WickedConcepts.html#partitioning",
    "title": "Wicked Concepts",
    "section": "Partitioning",
    "text": "Partitioning\n\nHeight equal to 15\n\n\nCode\n#Partitioning regular clustering - 15\nplot(cg.se,labels = cg.se$glabels)\nrect.hclust(cg.se$cluster, h = 15)\n\n\n\n\n\n\n\n\n\nCode\n#Partitioning Average Cluster Method - 15\nplot(cg.ase,labels = cg.ase$glabels)\nrect.hclust(cg.ase$cluster, h = 15)\n\n\n\n\n\n\n\n\n\nCode\n#Partitioning Single Cluster Method - 15\nplot(cg.sse,labels = cg.sse$glabels)\nrect.hclust(cg.sse$cluster, h = 15)\n\n\n\n\n\n\n\n\n\nCode\n#Partitioning Ward.D method -15\nplot(cg.wse,labels = cg.wse$glabels)\nrect.hclust(cg.se$cluster, h = 15)\n\n\n\n\n\n\n\n\n\n\n\nHeight equal to 10\n\n\nCode\n#Partitioning regular clustering -10\nplot(cg.se,labels = cg.se$glabels)\nrect.hclust(cg.se$cluster, h = 10)\n\n\n\n\n\n\n\n\n\nCode\n#Partitioning Average Cluster Method -10\nplot(cg.ase,labels = cg.ase$glabels)\nrect.hclust(cg.ase$cluster, h = 10)\n\n\n\n\n\n\n\n\n\nCode\n#Partitioning Single Cluster Method -10\nplot(cg.sse,labels = cg.sse$glabels)\nrect.hclust(cg.sse$cluster, h = 10)\n\n\n\n\n\n\n\n\n\nCode\n#Partitioning Ward.D method -10\nplot(cg.wse,labels = cg.wse$glabels)\nrect.hclust(cg.se$cluster, h = 10)"
  },
  {
    "objectID": "posts/post-with-code/WickedConcepts.html#blockmodeling",
    "href": "posts/post-with-code/WickedConcepts.html#blockmodeling",
    "title": "Wicked Concepts",
    "section": "BlockModeling",
    "text": "BlockModeling\n\nHeight at 15 k=3\n\n\nCode\n#testing block model\nblock_se &lt;-blockmodel(cg.stat, cg.se, k=3, h=15)\nblock_ase &lt;-blockmodel(cg.stat, cg.ase, k=3, h=15)\nblock_sse &lt;-blockmodel(cg.stat, cg.sse, k=3, h=15)\nblock_wse &lt;-blockmodel(cg.stat, cg.wse, k=5, h=15) #tryin out 5\n\n#View models\nplot.block(block_se, cex.lab=.5)\n\n\n\n\n\n\n\n\n\nCode\nplot.block(block_ase, cex.lab=.5)\n\n\n\n\n\n\n\n\n\nCode\nplot.block(block_sse, cex.lab=.5)\n\n\n\n\n\n\n\n\n\nCode\nplot.block(block_wse, cex.lab=.5)\n\n\n\n\n\n\n\n\n\n\n\nHeight at 10, k=3\n\n\nCode\n#testing block model\nblock_se &lt;-blockmodel(cg.stat, cg.se, k=3, h=10)\nblock_ase &lt;-blockmodel(cg.stat, cg.ase, k=3, h=10)\nblock_sse &lt;-blockmodel(cg.stat, cg.sse, k=3, h=10)\nblock_wse &lt;-blockmodel(cg.stat, cg.wse, k=5, h=10) #tryin out 5\n\n#View models\nplot.block(block_se, cex.lab=.5)\n\n\n\n\n\n\n\n\n\nCode\nplot.block(block_ase, cex.lab=.5)\n\n\n\n\n\n\n\n\n\nCode\nplot.block(block_sse, cex.lab=.5)\n\n\n\n\n\n\n\n\n\nCode\nplot.block(block_wse, cex.lab=.5)"
  },
  {
    "objectID": "posts/post-with-code/WickedConcepts.html#lets-plot-this",
    "href": "posts/post-with-code/WickedConcepts.html#lets-plot-this",
    "title": "Wicked Concepts",
    "section": "Let’s Plot this",
    "text": "Let’s Plot this\n\nStatnet\n\n\nCode\n# chosen blockmodel and chose partition partitions\ncg_mod &lt;- blockmodel(cg.stat, cg.se, k=5)\n# assign block membership to vertex attribute\ncg.stat%v%\"role\" &lt;- cg_mod$block.membership[match(cg.stat%v%\"vertex.names\",\n                                                     cg_mod$plabels)]\n\nGGally::ggnet2(cg.stat,\n               node.color = \"role\",\n               node.size = degree(cg.stat, gmode = \"graph\"),\n               node.label = \"vertex.names\",\n               node.alpha = .7)\n\n\n\n\n\n\n\n\n\n\n\nigraph\n\n\nCode\ncg.ig &lt;- graph_from_data_frame(cg_tnet)\nV(cg.ig)$role &lt;- cg_mod$block.membership[match(V(cg.ig)$name, cg_mod$plabels)]\nplot.igraph(cg.ig,\n            vertex.color = V(cg.ig)$role,\n            vertex.size = 0.5+(igraph::degree(cg.ig)*0.5))"
  },
  {
    "objectID": "posts/post-with-code/Wicked Problems.html",
    "href": "posts/post-with-code/Wicked Problems.html",
    "title": "Wicked Problems Proposal",
    "section": "",
    "text": "I am studying How connected do people perceive wicked problems to be. \nBecause I want to find out how flawed individuals view this country to be and how connected they believe problems are with each sharing.\nIn order to help my reader understand The concept of a wicked problem and the impact that it has on the countries current political landscape on policy implementation and governance.\n\n\n\nExtracted Concepts\n\nWicked problems\nPolitics\nPolicy\nGovernance\nperception\n\n\n\n\nOperationalize the concepts\n\nPerception - This is defined as whether or not the person believes the criteria is fair for the problem the algorithm is solving (Nominal) -Yes or No\nWicked Problems- a issue that multiple stakeholders disagree about the best way to solve the problem leading to ineffective policy solutions.\n Governance- how those impower use the rules to guide citizens\nPolicy - laws and directive put into place for people to follow, courses of action for governing officials."
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ClairVoyant Data Scientist",
    "section": "",
    "text": "Wicked Concepts\n\n\n\n\n\n\n\n\n\n\n\nRylyn Williams\n\n\n\n\n\n\n\n\n\n\n\n\nWicked Problems Proposal\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlots by Roles\n\n\n\n\n\n\n\n\n\n\n\nRylyn Williams\n\n\n\n\n\n\n\n\n\n\n\n\nPost With Code\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\nApr 30, 2024\n\n\nHarlow Malloc\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nApr 27, 2024\n\n\nTristan O’Malley\n\n\n\n\n\n\nNo matching items"
  }
]